diff --git a/home/keith/nostr-tools-orig/filter.js b/node_modules/nostr-tools/filter.js
index 37cf3a5..5e04150 100644
--- a/home/keith/nostr-tools-orig/filter.js
+++ b/node_modules/nostr-tools/filter.js
@@ -1,3 +1,5 @@
+import { isArray } from "lodash"
+
 export function matchFilter(filter, event) {
   if (filter.ids && filter.ids.indexOf(event.id) === -1) return false
   if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false
@@ -28,3 +30,140 @@ export function matchFilters(filters, event) {
   }
   return false
 }
+
+
+
+export function filterMatchRules(filter, rules) {
+
+  if(rules == undefined || rules == []) return true
+
+  let testFn = new Array()
+  testFn['/'] = (ruleVal, eventVal) => { return eventVal == null || eventVal == '' }
+  testFn['='] = (ruleVal, eventVal) => { return eventVal == ruleVal }
+  testFn['>'] = (ruleVal, eventVal) => { return parseInt(eventVal) > parseInt(ruleVal)  }
+  testFn['<'] = (ruleVal, eventVal) => { return parseInt(eventVal) < parseInt(ruleVal)  }
+  testFn['!'] = (ruleVal, eventVal) => { return eventVal != ruleVal }
+
+  const FIELD = 0
+  const SIGN = 1
+  const VALUE = 2
+
+  let uniqueTags = ['ids', 'authors', 'kinds', 'since', 'until', 'limit']
+  let ruleReqMet = false
+
+  for (let ruleGroup in rules) {
+    for (let rule in rules[ruleGroup]) {
+      for (const [filterKey, filterValue] of Object.entries(filter)) {
+        if (ruleReqMet) break
+        // If it's not a set tag, prepend the filter's necessary hash '#'
+        let curTag = rules[ruleGroup][rule][FIELD]
+        curTag = !uniqueTags.includes(rules[ruleGroup][rule][FIELD]) ? '#' + curTag : curTag
+        if(filterKey == curTag) {
+          let filterArr = typeof(filterValue) == 'object' ? filterValue : [filterValue]
+          for(let i in filterArr) {
+            if(testFn[rules[ruleGroup][rule][SIGN]](rules[ruleGroup][rule][VALUE], filter[curTag][i])) {
+              ruleReqMet = true
+              console.log(filter.tags[tag][1] + ' does ' + rules[ruleGroup][rule][SIGN] + ' ' + rules[ruleGroup][rule][VALUE])
+              break
+            } else {
+              console.log(filter.tags[tag][1] + ' does not ' + rules[ruleGroup][rule][SIGN] + ' ' + rules[ruleGroup][rule][VALUE])
+            }
+          }
+        }
+      }
+    }
+
+    return ruleReqMet
+  }
+
+}
+
+export function eventMatchRules(event, rules) {
+
+  if(rules == undefined || rules == []) return true
+
+  let testFn = new Array()
+  testFn['/'] = (ruleVal, eventVal) => { return eventVal == null }
+  testFn['='] = (ruleVal, eventVal) => { return eventVal == ruleVal }
+  testFn['>'] = (ruleVal, eventVal) => { return parseInt(eventVal) > parseInt(ruleVal)  }
+  testFn['<'] = (ruleVal, eventVal) => { return parseInt(eventVal) < parseInt(ruleVal)  }
+  testFn['!'] = (ruleVal, eventVal) => { return eventVal != ruleVal }
+
+  let uniqueTags = ['authors', 'content', 'id', 'created_at', 'sig', 'kind']
+
+  for (let ruleGroup in rules) {
+
+    const FIELD = 0
+    const SIGN = 1
+    const VALUE = 2
+
+    let curTag = ''
+
+    for (let rule in ruleGroup) {
+      for (let uniqueTag in uniqueTags) {
+        curTag = uniqueTags[uniqueTag]
+        // TODO: Make this work nicely with the ! operator check
+        if (rules[ruleGroup][rule][FIELD] == curTag && event[curTag] != undefined) {
+          if (!testFn[rules[ruleGroup][rule][SIGN]](rules[ruleGroup][rule][VALUE], event[curTag])) {
+            
+            console.log(event.tags[tag][1] + ' does not ' + rules[ruleGroup][rule][SIGN] + ' ' + rules[ruleGroup][rule][VALUE])
+
+            // If there's another rule to check in this group, don't fail just yet
+            if(rules[ruleGroup][parseInt(rule) + 1]) {
+              continue;
+            } else {
+              return false;
+            }
+          }
+        } else if (rules[ruleGroup][rule][FIELD] == curTag && event[curTag] == undefined) {
+          //  Is undefined, according to spec writes default to failing on malformed queries
+          if(rules[ruleGroup][parseInt(rule) + 1]) {
+            continue;
+          } else {
+            return false;
+          }
+        }
+      }
+
+      // Iterate through the event tags
+      for(let tag in event.tags) {
+        if(event.tags[tag][0] == rules[ruleGroup][rule][FIELD]
+            && !testFn[rules[ruleGroup][rule][SIGN]](rules[ruleGroup][rule][VALUE], event.tags[tag][1])) {
+          
+          console.log(event.tags[tag][1] + ' does not ' + rules[ruleGroup][rule][SIGN] + ' ' + rules[ruleGroup][rule][VALUE])
+
+          // If there's another rule to check in this group, don't fail just yet
+          if(rules[ruleGroup][parseInt(rule) + 1]) {
+            continue;
+          } else {
+            
+            return false;
+          }
+        }
+      }
+      
+    }
+  }
+  return true;
+}
+
+export function parseRules(ruleString) {
+
+  if(!ruleString) return false;
+
+  var rules = []
+  var rulePairs = ruleString.split('&')
+  const re = /(\w+)([|!=<>\/]?)([\da-z]*)/
+
+  for (var pair in rulePairs) {
+    var orRules = []
+    var orPairs = rulePairs[pair].split('|')
+    for (var orpair in orPairs) {
+      var parsed = orPairs[orpair].match(re);
+      orRules.push(parsed.slice(1))
+    }
+    rules.push(orRules)
+  }
+  return rules;
+
+}
\ No newline at end of file
diff --git a/home/keith/nostr-tools-orig/pool.js b/node_modules/nostr-tools/pool.js
index 84daa33..7f30601 100644
--- a/home/keith/nostr-tools-orig/pool.js
+++ b/node_modules/nostr-tools/pool.js
@@ -26,22 +26,23 @@ export function relayPool() {
 
   const activeSubscriptions = {}
 
-  const sub = ({cb, filter, beforeSend}, id) => {
+  const sub = ({cb, filter, beforeSend, rules}, id) => {
     if (!id) id = Math.random().toString().slice(2)
-
     const subControllers = Object.fromEntries(
       Object.values(relays)
         .filter(({policy}) => policy.read)
         .map(({relay}) => [
           relay.url,
-          relay.sub({cb: event => cb(event, relay.url), filter, beforeSend}, id)
+          relay.sub({cb: event => cb(event, relay.url), filter, beforeSend, rules}, id)
         ])
     )
+    console.log(' SUB()  IN NOSTR-TOOLS POOL.JS   ------------')
+    console.log(rules)
 
     const activeCallback = cb
     const activeFilters = filter
     const activeBeforeSend = beforeSend
-
+    const activeRules = rules
     const unsub = () => {
       Object.values(subControllers).forEach(sub => sub.unsub())
       delete activeSubscriptions[id]
@@ -49,17 +50,18 @@ export function relayPool() {
     const sub = ({
       cb = activeCallback,
       filter = activeFilters,
-      beforeSend = activeBeforeSend
+      beforeSend = activeBeforeSend,
+      rules = activeRules
     }) => {
       Object.entries(subControllers).map(([relayURL, sub]) => [
         relayURL,
-        sub.sub({cb: event => cb(event, relayURL), filter, beforeSend}, id)
+        sub.sub({cb: event => cb(event, relayURL), filter, beforeSend, rules}, id)
       ])
       return activeSubscriptions[id]
     }
     const addRelay = relay => {
       subControllers[relay.url] = relay.sub(
-        {cb: event => cb(event, relay.url), filter, beforeSend},
+        {cb: event => cb(event, relay.url), filter, beforeSend, rules:relay.rules},
         id
       )
       return activeSubscriptions[id]
@@ -94,16 +96,16 @@ export function relayPool() {
     setPolicy(key, value) {
       poolPolicy[key] = value
     },
-    addRelay(url, policy = {read: true, write: true}) {
+    addRelay(url, policy = {read: true, write: true}, rules = {read: [], write: []}) {
       let relayURL = normalizeRelayURL(url)
       if (relayURL in relays) return
-
       let relay = relayConnect(url, notice => {
-        propagateNotice(notice, relayURL)
-      })
-      relays[relayURL] = {relay, policy}
+        propagateNotice(notice, relayURL), null
+      }, null, rules)
+      relays[relayURL] = {relay, policy, rules}
 
       if (policy.read) {
+
         Object.values(activeSubscriptions).forEach(subscription =>
           subscription.addRelay(relay)
         )
diff --git a/home/keith/nostr-tools-orig/relay.js b/node_modules/nostr-tools/relay.js
index d8423b6..70ada10 100644
--- a/home/keith/nostr-tools-orig/relay.js
+++ b/node_modules/nostr-tools/relay.js
@@ -3,7 +3,7 @@
 import 'websocket-polyfill'
 
 import {verifySignature, validateEvent} from './event.js'
-import {matchFilters} from './filter.js'
+import {matchFilters, parseRules, eventMatchRules, filter, filterMatchRules} from './filter.js'
 
 export function normalizeRelayURL(url) {
   let [host, ...qs] = url.trim().split('?')
@@ -13,11 +13,12 @@ export function normalizeRelayURL(url) {
   return [host, ...qs].join('?')
 }
 
-export function relayConnect(url, onNotice = () => {}, onError = () => {}) {
+export function relayConnect(url, onNotice = () => {}, onError = () => {}, rules = []) {
   url = normalizeRelayURL(url)
 
   var ws, resolveOpen, untilOpen, wasClosed
   var openSubs = {}
+  var ruleList = {}
   var isSetToSkipVerification = {}
   let attemptNumber = 1
   let nextAttemptSeconds = 1
@@ -43,7 +44,8 @@ export function relayConnect(url, onNotice = () => {}, onError = () => {}) {
         for (let channel in openSubs) {
           let filters = openSubs[channel]
           let cb = channels[channel]
-          sub({cb, filter: filters}, channel)
+          let rules = ruleList[channel]
+          sub({cb, filter: filters, rules: rules}, channel)
         }
       }
     }
@@ -136,24 +138,40 @@ export function relayConnect(url, onNotice = () => {}, onError = () => {}) {
       filters = beforeSendResult.filter
     }
 
-    trySend(['REQ', channel, ...filters])
+    let ruleFollowers = filters.filter((f) => {
+      if(filterMatchRules(f, parseRules(rules.read))) {
+        console.log('Filter passed', f)
+        return true
+      } else {
+        console.log('Filter failed', f)
+        return false
+      }
+    })
+
+    if(ruleFollowers.length) {
+      console.log(['REQ', channel, ...ruleFollowers])
+      trySend(['REQ', channel, ...ruleFollowers])
+    }
+    
     channels[channel] = cb
     openSubs[channel] = filters
+    ruleList[channel] = rules
     isSetToSkipVerification[channel] = skipVerification
-
     const activeCallback = cb
     const activeFilters = filters
     const activeBeforeSend = beforeSend
-
+    const activeRules = rules
     return {
       sub: ({
         cb = activeCallback,
         filter = activeFilters,
-        beforeSend = activeBeforeSend
-      }) => sub({cb, filter, beforeSend, skipVerification}, channel),
+        beforeSend = activeBeforeSend,
+        rules = activeRules
+      }) => sub({cb, filter, beforeSend, skipVerification, rules}, channel),
       unsub: () => {
         delete openSubs[channel]
         delete channels[channel]
+        delete rules[channel]
         delete isSetToSkipVerification[channel]
         trySend(['CLOSE', channel])
       }
@@ -165,21 +183,24 @@ export function relayConnect(url, onNotice = () => {}, onError = () => {}) {
     sub,
     async publish(event, statusCallback) {
       try {
-        await trySend(['EVENT', event])
-        if (statusCallback) {
-          statusCallback(0)
-          let {unsub} = sub(
-            {
-              cb: () => {
-                statusCallback(1)
-                unsub()
-                clearTimeout(willUnsub)
+        if(eventMatchRules(event, parseRules(rules.write))) {
+          await trySend(['EVENT', event])
+          if (statusCallback) {
+            statusCallback(0)
+            let {unsub} = sub(
+              {
+                cb: () => {
+                  statusCallback(1)
+                  unsub()
+                  clearTimeout(willUnsub)
+                },
+                filter: {ids: [event.id]},
+                rules: relays[url].rules
               },
-              filter: {ids: [event.id]}
-            },
-            `monitor-${event.id.slice(0, 5)}`
-          )
-          let willUnsub = setTimeout(unsub, 5000)
+              `monitor-${event.id.slice(0, 5)}`
+            )
+            let willUnsub = setTimeout(unsub, 5000)
+          }
         }
       } catch (err) {
         if (statusCallback) statusCallback(-1)
